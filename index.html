<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krusty Krab Drawing Animation</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(circle at 30% 70%, #1a1a1a 0%, #2c2c2c 50%, #1f1f1f 100%),
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%, transparent 75%, #2a2a2a 75%);
            background-size: 100% 100%, 20px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Georgia', 'Times New Roman', serif;
            perspective: 1000px;
        }
        
        .container {
            width: 360px;
            height: 640px;
            background: 
                linear-gradient(135deg, #faf8f2 0%, #f6f3ec 20%, #f2efe6 40%, #eee9dd 60%, #ebe6d8 80%, #e8e3d5 100%),
                radial-gradient(circle at 25% 15%, rgba(139, 69, 19, 0.04) 0%, transparent 60%),
                radial-gradient(circle at 75% 85%, rgba(160, 82, 45, 0.03) 0%, transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(101, 67, 33, 0.02) 0%, transparent 80%);
            border-radius: 12px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.4),
                0 8px 16px rgba(0,0,0,0.2),
                inset 0 2px 4px rgba(255,255,255,0.7),
                inset 0 -2px 4px rgba(0,0,0,0.1),
                inset 1px 1px 2px rgba(255,255,255,0.5),
                inset -1px -1px 2px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            border: 2px solid #d8c9ab;
            transform: rotateX(2deg) rotateY(-1deg);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .container:hover {
            transform: rotateX(0deg) rotateY(0deg) translateY(-5px);
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.5),
                0 12px 20px rgba(0,0,0,0.3),
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.1);
        }
        
        .paper-texture {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            background-image: 
                /* Enhanced fiber texture */
                radial-gradient(circle at 12% 18%, rgba(139, 69, 19, 0.12) 0.8px, transparent 1px),
                radial-gradient(circle at 78% 62%, rgba(160, 82, 45, 0.09) 1.2px, transparent 1.5px),
                radial-gradient(circle at 43% 87%, rgba(101, 67, 33, 0.08) 0.6px, transparent 1px),
                radial-gradient(circle at 67% 23%, rgba(139, 69, 19, 0.06) 1px, transparent 1.5px),
                radial-gradient(circle at 23% 56%, rgba(160, 82, 45, 0.07) 0.9px, transparent 1.2px),
                /* Paper grain enhancement */
                linear-gradient(92deg, transparent 0%, rgba(139, 69, 19, 0.03) 30%, rgba(160, 82, 45, 0.04) 70%, transparent 100%),
                linear-gradient(2deg, transparent 0%, rgba(101, 67, 33, 0.02) 40%, rgba(139, 69, 19, 0.03) 60%, transparent 100%),
                /* Micro texture */
                repeating-linear-gradient(45deg, rgba(139, 69, 19, 0.01) 0px, transparent 1px, rgba(160, 82, 45, 0.01) 2px);
            background-size: 
                140px 95px,
                110px 130px,
                170px 85px,
                95px 115px,
                125px 90px,
                12px 8px,
                8px 6px,
                3px 3px;
            mix-blend-mode: multiply;
        }
        
        .book-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 26px,
                    rgba(70, 130, 180, 0.4) 26px,
                    rgba(70, 130, 180, 0.35) 27px,
                    rgba(70, 130, 180, 0.2) 28px,
                    transparent 28px
                );
        }
        
        .margin-line {
            position: absolute;
            left: 42px;
            top: 0;
            width: 1.5px;
            height: 100%;
            background: 
                linear-gradient(
                    to bottom,
                    rgba(255, 182, 193, 0.6) 0%,
                    rgba(255, 182, 193, 0.5) 20%,
                    rgba(255, 182, 193, 0.4) 50%,
                    rgba(255, 182, 193, 0.5) 80%,
                    rgba(255, 182, 193, 0.6) 100%
                );
            border-radius: 1px;
        }
        
        .stains {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                /* Coffee stains */
                radial-gradient(ellipse 35px 25px at 18% 28%, rgba(139, 69, 19, 0.12) 40%, rgba(101, 67, 33, 0.08) 60%, transparent 80%),
                radial-gradient(ellipse 25px 18px at 83% 72%, rgba(160, 82, 45, 0.09) 35%, rgba(139, 69, 19, 0.06) 55%, transparent 75%),
                radial-gradient(ellipse 40px 30px at 62% 12%, rgba(101, 67, 33, 0.06) 30%, rgba(160, 82, 45, 0.04) 50%, transparent 70%),
                /* Ink spots */
                radial-gradient(ellipse 8px 12px at 35% 45%, rgba(25, 25, 112, 0.08) 50%, transparent 70%),
                radial-gradient(ellipse 6px 8px at 75% 85%, rgba(72, 61, 139, 0.06) 40%, transparent 60%),
                /* Wear marks */
                radial-gradient(ellipse 60px 20px at 50% 95%, rgba(139, 69, 19, 0.05) 20%, transparent 50%),
                radial-gradient(ellipse 40px 15px at 20% 5%, rgba(160, 82, 45, 0.04) 30%, transparent 60%);
            mix-blend-mode: multiply;
        }
        
        /* Notebook rings/binding */
        .binding {
            position: absolute;
            left: 0;
            top: 0;
            width: 20px;
            height: 100%;
            background: 
                linear-gradient(to right, 
                    rgba(139, 69, 19, 0.1) 0%, 
                    rgba(160, 82, 45, 0.08) 50%, 
                    transparent 100%
                );
            border-right: 1px solid rgba(139, 69, 19, 0.2);
        }
        
        .binding::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 10%;
            width: 4px;
            height: 80%;
            background: 
                repeating-linear-gradient(
                    to bottom,
                    rgba(139, 69, 19, 0.3) 0px,
                    rgba(139, 69, 19, 0.3) 15px,
                    transparent 15px,
                    transparent 25px
                );
            border-radius: 2px;
        }
        
        canvas {
            display: block;
            margin: 30px auto;
            background: transparent;
            border-radius: 4px;
        }
        
        .pencil {
            position: absolute;
            width: 140px;
            height: 10px;
            background: 
                linear-gradient(90deg, 
                    #8b4513 0%, 
                    #d4af37 15%, 
                    #ffd700 50%, 
                    #d4af37 85%, 
                    #8b4513 100%
                );
            border-radius: 5px;
            transform-origin: 100% 50%;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 
                0 3px 6px rgba(0,0,0,0.3),
                inset 0 1px 2px rgba(255,255,255,0.4),
                inset 0 -1px 2px rgba(0,0,0,0.2);
        }
        
        .pencil::before {
            content: '';
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid #2c2c2c;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
        }
        
        .pencil::after {
            content: '';
            position: absolute;
            left: 8px;
            top: 2px;
            width: 80px;
            height: 2px;
            background: 
                linear-gradient(90deg, 
                    rgba(255, 255, 255, 0.6) 0%, 
                    rgba(255, 255, 255, 0.4) 50%, 
                    rgba(255, 255, 255, 0.2) 100%
                );
            border-radius: 1px;
        }
        
        /* Eraser */
        .pencil .eraser {
            position: absolute;
            left: -15px;
            top: 1px;
            width: 12px;
            height: 8px;
            background: 
                linear-gradient(90deg, 
                    #ff69b4 0%, 
                    #ff1493 50%, 
                    #dc143c 100%
                );
            border-radius: 2px;
            border: 1px solid #b8860b;
        }
        
        /* Page corner fold */
        .page-fold {
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 30px;
            background: 
                linear-gradient(225deg, 
                    rgba(139, 69, 19, 0.1) 0%, 
                    rgba(160, 82, 45, 0.08) 50%, 
                    transparent 100%
                );
            clip-path: polygon(100% 0%, 0% 100%, 100% 100%);
            box-shadow: inset -2px 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Subtle animation for texture */
        @keyframes paperShimmer {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.7; }
        }
        
        .paper-texture {
            animation: paperShimmer 4s ease-in-out infinite;
        }
        
        /* Responsive adjustments */
        @media (max-width: 480px) {
            .container {
                width: 320px;
                height: 560px;
                margin: 20px;
            }
        }
        
        @media (max-height: 700px) {
            .container {
                height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="paper-texture"></div>
        <div class="book-lines"></div>
        <div class="margin-line"></div>
        <div class="stains"></div>
        <canvas id="drawingCanvas" width="320" height="580"></canvas>
        <div class="pencil" id="pencil"></div>
    </div>

    <script>
        class KrustyKrabAnimator {
    constructor(canvasId, pencilId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.pencil = document.getElementById(pencilId);
        
        // Animation state
        this.animationId = null;
        this.currentPhase = 0;
        this.progress = 0;
        this.isAnimating = false;
        this.startTime = null;
        
        // Enhanced configuration
        this.config = {
            phases: [
                { name: 'sketch', duration: 5000, color: '#888', lineWidth: 1.5, opacity: 0.6, style: 'rough' },
                { name: 'refine', duration: 4000, color: '#555', lineWidth: 2, opacity: 0.8, style: 'smooth' },
                { name: 'ink', duration: 3000, color: '#222', lineWidth: 2.5, opacity: 1, style: 'precise' },
                { name: 'color', duration: 6000, color: 'multicolor', lineWidth: 0, opacity: 1, style: 'fill' },
                { name: 'highlight', duration: 1500, color: 'effects', lineWidth: 0, opacity: 1, style: 'effects' },
                { name: 'pause', duration: 2000, color: 'transparent', lineWidth: 0, opacity: 1, style: 'none' }
            ],
            easing: {
                easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
                easeOutBounce: t => {
                    if (t < 1 / 2.75) return 7.5625 * t * t;
                    if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                    if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                }
            }
        };
        
        // Enhanced structure with smooth curves
        this.structure = this.initializeStructure();
        this.colors = this.initializeColors();
        
        this.setupCanvas();
        this.bindEvents();
    }
    
    initializeStructure() {
        return {
            base: {
                points: [[60, 450], [260, 450], [260, 350], [60, 350]],
                closed: true,
                priority: 1
            },
            roof: {
                points: [[50, 350], [80, 300], [120, 280], [160, 270], [200, 280], [240, 300], [270, 350]],
                closed: false,
                priority: 2,
                smooth: true
            },
            signPost: {
                points: [[30, 250], [30, 450]],
                closed: false,
                priority: 3
            },
            sign: {
                points: [[10, 220], [50, 200], [70, 220], [60, 250], [40, 260], [20, 250]],
                closed: true,
                priority: 4,
                smooth: true
            },
            door: {
                points: [[140, 450], [140, 380], [180, 380], [180, 450]],
                closed: false,
                priority: 5
            },
            leftWindow: {
                points: [[80, 420], [120, 420], [120, 390], [80, 390]],
                closed: true,
                priority: 6
            },
            rightWindow: {
                points: [[200, 420], [240, 420], [240, 390], [200, 390]],
                closed: true,
                priority: 7
            },
            chimney: {
                points: [[200, 270], [200, 240], [220, 240], [220, 270]],
                closed: true,
                priority: 8
            },
            bunting: {
                points: [[70, 330], [90, 320], [110, 330], [130, 320], [150, 330], [170, 320], [190, 330], [210, 320], [230, 330], [250, 320]],
                closed: false,
                priority: 9
            }
        };
    }
    
    initializeColors() {
        return {
            base: { primary: '#8B4513', secondary: '#A0522D', highlight: '#CD853F' },
            roof: { primary: '#654321', secondary: '#8B4513', highlight: '#A0522D' },
            sign: { primary: '#FFF', secondary: '#F5F5F5', highlight: '#FFF' },
            signText: '#8B0000',
            door: { primary: '#4169E1', secondary: '#1E90FF', highlight: '#87CEEB' },
            windows: { primary: '#87CEEB', secondary: '#B0E0E6', highlight: '#E0F6FF' },
            chimney: { primary: '#2F4F4F', secondary: '#708090', highlight: '#778899' },
            bunting: ['#FF4444', '#FFD700', '#4169E1', '#FF6347', '#32CD32', '#FF1493'],
            background: { top: '#4169E1', bottom: '#1E90FF' },
            ground: '#F5DEB3',
            effects: {
                bubbles: 'rgba(255, 255, 255, 0.4)',
                smoke: '#999',
                glow: 'rgba(255, 255, 255, 0.8)'
            }
        };
    }
    
    setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
    }
    
    bindEvents() {
        window.addEventListener('resize', this.debounce(() => this.setupCanvas(), 250));
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.pause();
            } else {
                this.resume();
            }
        });
    }
    
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    drawBackground(phase = 0) {
        // Enhanced gradient background
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, this.colors.background.top);
        gradient.addColorStop(0.6, this.colors.background.bottom);
        gradient.addColorStop(1, '#191970');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height * 0.85);
        
        // Animated ground with texture
        const groundGradient = this.ctx.createLinearGradient(0, this.canvas.height * 0.85, 0, this.canvas.height);
        groundGradient.addColorStop(0, this.colors.ground);
        groundGradient.addColorStop(1, '#DEB887');
        
        this.ctx.fillStyle = groundGradient;
        this.ctx.fillRect(0, this.canvas.height * 0.85, this.canvas.width, this.canvas.height * 0.15);
        
        // Enhanced bubbles with animation
        this.drawBubbles(phase);
    }
    
    drawBubbles(phase) {
        const bubbleCount = 12;
        const time = Date.now() * 0.001;
        
        this.ctx.fillStyle = this.colors.effects.bubbles;
        
        for (let i = 0; i < bubbleCount; i++) {
            const x = (i * 47 + Math.sin(time + i) * 20) % this.canvas.width;
            const y = Math.sin(time * 0.5 + i * 0.8) * this.canvas.height * 0.4 + this.canvas.height * 0.3;
            const radius = Math.sin(time + i) * 2 + 3;
            const opacity = (Math.sin(time * 0.3 + i) + 1) * 0.2 + 0.1;
            
            this.ctx.globalAlpha = opacity;
            this.ctx.beginPath();
            this.ctx.arc(x, y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        }
        
        this.ctx.globalAlpha = 1;
    }
    
    drawSmoothPath(points, closed = false) {
        if (points.length < 2) return;
        
        this.ctx.beginPath();
        this.ctx.moveTo(points[0][0], points[0][1]);
        
        if (points.length === 2) {
            this.ctx.lineTo(points[1][0], points[1][1]);
        } else {
            // Use quadratic curves for smoother lines
            for (let i = 1; i < points.length - 1; i++) {
                const xc = (points[i][0] + points[i + 1][0]) / 2;
                const yc = (points[i][1] + points[i + 1][1]) / 2;
                this.ctx.quadraticCurveTo(points[i][0], points[i][1], xc, yc);
            }
            
            if (closed) {
                const xc = (points[points.length - 1][0] + points[0][0]) / 2;
                const yc = (points[points.length - 1][1] + points[0][1]) / 2;
                this.ctx.quadraticCurveTo(points[points.length - 1][0], points[points.length - 1][1], xc, yc);
                this.ctx.quadraticCurveTo(points[0][0], points[0][1], points[0][0], points[0][1]);
            } else {
                this.ctx.lineTo(points[points.length - 1][0], points[points.length - 1][1]);
            }
        }
        
        if (closed) {
            this.ctx.closePath();
        }
    }
    
    drawRoughPath(points, closed = false) {
        if (points.length < 2) return;
        
        this.ctx.beginPath();
        this.ctx.moveTo(points[0][0] + Math.random() * 2 - 1, points[0][1] + Math.random() * 2 - 1);
        
        for (let i = 1; i < points.length; i++) {
            const x = points[i][0] + Math.random() * 3 - 1.5;
            const y = points[i][1] + Math.random() * 3 - 1.5;
            this.ctx.lineTo(x, y);
        }
        
        if (closed) {
            this.ctx.closePath();
        }
    }
    
    drawStructurePhase(phase, progress) {
        const phaseConfig = this.config.phases[phase];
        const easedProgress = this.config.easing.easeInOutCubic(progress);
        
        // Set drawing style
        this.ctx.lineWidth = phaseConfig.lineWidth;
        this.ctx.globalAlpha = phaseConfig.opacity;
        this.ctx.strokeStyle = phaseConfig.color;
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
        
        // Calculate which parts to draw
        const sortedParts = Object.entries(this.structure)
            .sort(([,a], [,b]) => a.priority - b.priority);
        
        const totalParts = sortedParts.length;
        const partsToShow = Math.floor(totalParts * easedProgress);
        const partialProgress = (totalParts * easedProgress) % 1;
        
        for (let i = 0; i < sortedParts.length; i++) {
            const [name, part] = sortedParts[i];
            
            if (i < partsToShow) {
                this.drawPart(part, phaseConfig.style, 1);
            } else if (i === partsToShow && partialProgress > 0) {
                this.drawPart(part, phaseConfig.style, partialProgress);
            }
        }
        
        this.ctx.globalAlpha = 1;
    }
    
    drawPart(part, style, progress) {
        const points = part.points;
        const drawCount = Math.max(2, Math.floor(points.length * progress));
        const partialPoints = points.slice(0, drawCount);
        
        switch (style) {
            case 'rough':
                this.drawRoughPath(partialPoints, part.closed && progress >= 1);
                break;
            case 'smooth':
            case 'precise':
                this.drawSmoothPath(partialPoints, part.closed && progress >= 1);
                break;
        }
        
        this.ctx.stroke();
    }
    
    drawColorPhase(progress) {
        const easedProgress = this.config.easing.easeOutBounce(progress);
        
        this.drawBackground(this.currentPhase);
        
        // Draw filled shapes with gradients
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = '#000';
        this.ctx.globalAlpha = easedProgress;
        
        this.drawFilledStructures();
        this.drawDetails();
        
        this.ctx.globalAlpha = 1;
    }
    
    drawFilledStructures() {
        // Base with gradient
        const baseGradient = this.ctx.createLinearGradient(60, 350, 260, 450);
        baseGradient.addColorStop(0, this.colors.base.highlight);
        baseGradient.addColorStop(0.5, this.colors.base.primary);
        baseGradient.addColorStop(1, this.colors.base.secondary);
        
        this.ctx.fillStyle = baseGradient;
        this.ctx.fillRect(60, 350, 200, 100);
        this.ctx.strokeRect(60, 350, 200, 100);
        
        // Roof with curved path
        const roofGradient = this.ctx.createLinearGradient(50, 270, 270, 350);
        roofGradient.addColorStop(0, this.colors.roof.highlight);
        roofGradient.addColorStop(1, this.colors.roof.primary);
        
        this.ctx.fillStyle = roofGradient;
        this.ctx.beginPath();
        this.drawSmoothPath(this.structure.roof.points, false);
        this.ctx.lineTo(270, 350);
        this.ctx.lineTo(50, 350);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        
        // Continue with other structures...
        this.drawSign();
        this.drawDoorAndWindows();
        this.drawChimney();
        this.drawBunting();
    }
    
    drawSign() {
        // Sign with shadow effect
        this.ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        this.ctx.shadowBlur = 5;
        this.ctx.shadowOffsetX = 2;
        this.ctx.shadowOffsetY = 2;
        
        this.ctx.fillStyle = this.colors.sign.primary;
        this.ctx.beginPath();
        this.drawSmoothPath(this.structure.sign.points, true);
        this.ctx.fill();
        this.ctx.stroke();
        
        this.ctx.shadowColor = 'transparent';
        
        // Enhanced sign text
        this.ctx.fillStyle = this.colors.signText;
        this.ctx.font = 'bold 11px "Arial Black", Arial';
        this.ctx.textAlign = 'center';
        this.ctx.strokeStyle = '#FFF';
        this.ctx.lineWidth = 3;
        
        const texts = ['THE', 'KRUSTY', 'KRAB'];
        texts.forEach((text, i) => {
            const y = 225 + i * 12;
            this.ctx.strokeText(text, 40, y);
            this.ctx.fillText(text, 40, y);
        });
    }
    
    drawDoorAndWindows() {
        // Door with gradient
        const doorGradient = this.ctx.createLinearGradient(140, 380, 180, 450);
        doorGradient.addColorStop(0, this.colors.door.highlight);
        doorGradient.addColorStop(1, this.colors.door.primary);
        
        this.ctx.fillStyle = doorGradient;
        this.ctx.fillRect(140, 380, 40, 70);
        this.ctx.strokeRect(140, 380, 40, 70);
        
        // Door knob with shine
        this.ctx.fillStyle = '#FFD700';
        this.ctx.beginPath();
        this.ctx.arc(170, 415, 3, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.fillStyle = '#FFF';
        this.ctx.beginPath();
        this.ctx.arc(169, 413, 1, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Windows with reflection effect
        const windowGradient = this.ctx.createLinearGradient(0, 390, 0, 420);
        windowGradient.addColorStop(0, this.colors.windows.highlight);
        windowGradient.addColorStop(0.5, this.colors.windows.primary);
        windowGradient.addColorStop(1, this.colors.windows.secondary);
        
        this.ctx.fillStyle = windowGradient;
        this.ctx.fillRect(80, 390, 40, 30);
        this.ctx.strokeRect(80, 390, 40, 30);
        this.ctx.fillRect(200, 390, 40, 30);
        this.ctx.strokeRect(200, 390, 40, 30);
        
        // Window frames
        this.ctx.strokeStyle = '#000';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(100, 390);
        this.ctx.lineTo(100, 420);
        this.ctx.moveTo(80, 405);
        this.ctx.lineTo(120, 405);
        this.ctx.moveTo(220, 390);
        this.ctx.lineTo(220, 420);
        this.ctx.moveTo(200, 405);
        this.ctx.lineTo(240, 405);
        this.ctx.stroke();
    }
    
    drawChimney() {
        const chimneyGradient = this.ctx.createLinearGradient(200, 240, 220, 270);
        chimneyGradient.addColorStop(0, this.colors.chimney.highlight);
        chimneyGradient.addColorStop(1, this.colors.chimney.primary);
        
        this.ctx.fillStyle = chimneyGradient;
        this.ctx.fillRect(200, 240, 20, 30);
        this.ctx.strokeRect(200, 240, 20, 30);
        
        // Animated smoke
        this.drawSmoke();
    }
    
    drawSmoke() {
        const time = Date.now() * 0.003;
        this.ctx.strokeStyle = this.colors.effects.smoke;
        this.ctx.lineWidth = 2;
        this.ctx.lineCap = 'round';
        
        for (let i = 0; i < 3; i++) {
            this.ctx.globalAlpha = 0.6 - i * 0.1;
            this.ctx.beginPath();
            this.ctx.moveTo(210, 240 - i * 10);
            
            for (let j = 0; j < 5; j++) {
                const x = 210 + Math.sin(time + i + j * 0.5) * (j + 1) * 3;
                const y = 240 - i * 10 - j * 8;
                this.ctx.lineTo(x, y);
            }
            
            this.ctx.stroke();
        }
        
        this.ctx.globalAlpha = 1;
    }
    
    drawBunting() {
        // Bunting rope
        this.ctx.strokeStyle = '#8B4513';
        this.ctx.lineWidth = 3;
        this.drawSmoothPath(this.structure.bunting.points, false);
        
        // Bunting flags with animation
        const time = Date.now() * 0.002;
        
        for (let i = 0; i < this.structure.bunting.points.length - 1; i += 2) {
            const [x1, y1] = this.structure.bunting.points[i];
            const [x2, y2] = this.structure.bunting.points[i + 1];
            
            const wave = Math.sin(time + i) * 2;
            
            this.ctx.fillStyle = this.colors.bunting[Math.floor(i / 2) % this.colors.bunting.length];
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.lineTo(x1 + 15, y1 + 10 + wave);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        }
    }
    
    drawDetails() {
        // Add final details and highlights
        this.ctx.strokeStyle = '#000';
        this.ctx.lineWidth = 1;
        
        // Sign post
        this.ctx.lineWidth = 4;
        this.ctx.strokeStyle = '#8B4513';
        this.ctx.beginPath();
        this.ctx.moveTo(30, 250);
        this.ctx.lineTo(30, 450);
        this.ctx.stroke();
    }
    
    drawHighlightEffects(progress) {
        const easedProgress = this.config.easing.easeInOutCubic(progress);
        
        // Glow effect on windows
        this.ctx.shadowColor = this.colors.effects.glow;
        this.ctx.shadowBlur = 10 * easedProgress;
        this.ctx.globalAlpha = 0.5 * easedProgress;
        
        this.ctx.fillStyle = this.colors.windows.highlight;
        this.ctx.fillRect(80, 390, 40, 30);
        this.ctx.fillRect(200, 390, 40, 30);
        
        this.ctx.shadowColor = 'transparent';
        this.ctx.shadowBlur = 0;
        this.ctx.globalAlpha = 1;
    }
    
    updatePencilPosition(phase, progress) {
        if (phase >= 3) {
            this.pencil.style.opacity = '0';
            return;
        }
        
        this.pencil.style.opacity = '1';
        
        const sortedParts = Object.entries(this.structure)
            .sort(([,a], [,b]) => a.priority - b.priority);
        
        const totalParts = sortedParts.length;
        const currentPartIndex = Math.floor(totalParts * progress);
        const partProgress = (totalParts * progress) % 1;
        
        if (currentPartIndex < sortedParts.length) {
            const [, part] = sortedParts[currentPartIndex];
            const points = part.points;
            
            if (points.length > 0) {
                const pointIndex = Math.min(
                    Math.floor((points.length - 1) * partProgress),
                    points.length - 1
                );
                const [x, y] = points[pointIndex];
                
                // Smooth pencil movement
                const currentX = parseFloat(this.pencil.style.left) || x;
                const currentY = parseFloat(this.pencil.style.top) || y;
                
                const newX = currentX + (x - 60 - currentX) * 0.3;
                const newY = currentY + (y + 20 - currentY) * 0.3;
                
                this.pencil.style.left = `${newX}px`;
                this.pencil.style.top = `${newY}px`;
                
                // Add subtle rotation based on drawing direction
                const angle = pointIndex > 0 ? 
                    Math.atan2(points[pointIndex][1] - points[pointIndex-1][1], 
                              points[pointIndex][0] - points[pointIndex-1][0]) * 180 / Math.PI : 0;
                
                this.pencil.style.transform = `rotate(${angle + 45}deg)`;
            }
        }
    }
    
    animate(timestamp) {
        if (!this.isAnimating) return;
        
        if (!this.startTime) this.startTime = timestamp;
        const elapsed = timestamp - this.startTime;
        const currentPhase = this.config.phases[this.currentPhase];
        
        if (elapsed >= currentPhase.duration) {
            this.currentPhase++;
            this.progress = 0;
            this.startTime = timestamp;
            
            if (this.currentPhase >= this.config.phases.length) {
                this.currentPhase = 0;
                this.clearCanvas();
                this.pencil.style.opacity = '0';
                setTimeout(() => {
                    this.startTime = null;
                }, 1000);
            }
        } else {
            this.progress = elapsed / currentPhase.duration;
        }
        
        // Render current phase
        this.clearCanvas();
        
        switch (this.currentPhase) {
            case 0:
            case 1:
            case 2:
                this.drawStructurePhase(this.currentPhase, this.progress);
                this.updatePencilPosition(this.currentPhase, this.progress);
                break;
            case 3:
                this.drawColorPhase(this.progress);
                break;
            case 4:
                this.drawColorPhase(1);
                this.drawHighlightEffects(this.progress);
                break;
            case 5:
                this.drawColorPhase(1);
                break;
        }
        
        this.animationId = requestAnimationFrame(this.animate.bind(this));
    }
    
    start() {
        this.isAnimating = true;
        this.currentPhase = 0;
        this.progress = 0;
        this.startTime = null;
        this.animationId = requestAnimationFrame(this.animate.bind(this));
    }
    
    pause() {
        this.isAnimating = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
    
    resume() {
        if (!this.isAnimating) {
            this.isAnimating = true;
            this.startTime = null;
            this.animationId = requestAnimationFrame(this.animate.bind(this));
        }
    }
    
    reset() {
        this.pause();
        this.currentPhase = 0;
        this.progress = 0;
        this.clearCanvas();
        this.pencil.style.opacity = '0';
    }
}

// Initialize and start animation
const animator = new KrustyKrabAnimator('drawingCanvas', 'pencil');

// Auto-start with delay
setTimeout(() => {
    animator.start();
}, 1000);

// Expose methods for external control if needed
window.krustyKrabAnimator = animator;
    </script>
</body>
</html>
