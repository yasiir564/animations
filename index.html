<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpongeBob's Pineapple House Drawing Animation</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(circle at 30% 70%, #1a1a1a 0%, #2c2c2c 50%, #1f1f1f 100%),
                linear-gradient(45deg, #2a2a2a 25%, transparent 25%, transparent 75%, #2a2a2a 75%);
            background-size: 100% 100%, 20px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Georgia', 'Times New Roman', serif;
            perspective: 1000px;
        }
        
        .container {
            width: 360px;
            height: 640px;
            background: 
                linear-gradient(135deg, #faf8f2 0%, #f6f3ec 20%, #f2efe6 40%, #eee9dd 60%, #ebe6d8 80%, #e8e3d5 100%),
                radial-gradient(circle at 25% 15%, rgba(139, 69, 19, 0.04) 0%, transparent 60%),
                radial-gradient(circle at 75% 85%, rgba(160, 82, 45, 0.03) 0%, transparent 60%),
                radial-gradient(circle at 50% 50%, rgba(101, 67, 33, 0.02) 0%, transparent 80%);
            border-radius: 12px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.4),
                0 8px 16px rgba(0,0,0,0.2),
                inset 0 2px 4px rgba(255,255,255,0.7),
                inset 0 -2px 4px rgba(0,0,0,0.1),
                inset 1px 1px 2px rgba(255,255,255,0.5),
                inset -1px -1px 2px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
            border: 2px solid #d8c9ab;
            transform: rotateX(2deg) rotateY(-1deg);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .container:hover {
            transform: rotateX(0deg) rotateY(0deg) translateY(-5px);
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.5),
                0 12px 20px rgba(0,0,0,0.3),
                inset 0 2px 4px rgba(255,255,255,0.8),
                inset 0 -2px 4px rgba(0,0,0,0.1);
        }
        
        .paper-texture {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            background-image: 
                radial-gradient(circle at 12% 18%, rgba(139, 69, 19, 0.12) 0.8px, transparent 1px),
                radial-gradient(circle at 78% 62%, rgba(160, 82, 45, 0.09) 1.2px, transparent 1.5px),
                radial-gradient(circle at 43% 87%, rgba(101, 67, 33, 0.08) 0.6px, transparent 1px),
                radial-gradient(circle at 67% 23%, rgba(139, 69, 19, 0.06) 1px, transparent 1.5px),
                radial-gradient(circle at 23% 56%, rgba(160, 82, 45, 0.07) 0.9px, transparent 1.2px),
                linear-gradient(92deg, transparent 0%, rgba(139, 69, 19, 0.03) 30%, rgba(160, 82, 45, 0.04) 70%, transparent 100%),
                linear-gradient(2deg, transparent 0%, rgba(101, 67, 33, 0.02) 40%, rgba(139, 69, 19, 0.03) 60%, transparent 100%),
                repeating-linear-gradient(45deg, rgba(139, 69, 19, 0.01) 0px, transparent 1px, rgba(160, 82, 45, 0.01) 2px);
            background-size: 
                140px 95px,
                110px 130px,
                170px 85px,
                95px 115px,
                125px 90px,
                12px 8px,
                8px 6px,
                3px 3px;
            mix-blend-mode: multiply;
            animation: paperShimmer 4s ease-in-out infinite;
        }
        
        .book-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 26px,
                    rgba(70, 130, 180, 0.4) 26px,
                    rgba(70, 130, 180, 0.35) 27px,
                    rgba(70, 130, 180, 0.2) 28px,
                    transparent 28px
                );
        }
        
        .margin-line {
            position: absolute;
            left: 42px;
            top: 0;
            width: 1.5px;
            height: 100%;
            background: 
                linear-gradient(
                    to bottom,
                    rgba(255, 182, 193, 0.6) 0%,
                    rgba(255, 182, 193, 0.5) 20%,
                    rgba(255, 182, 193, 0.4) 50%,
                    rgba(255, 182, 193, 0.5) 80%,
                    rgba(255, 182, 193, 0.6) 100%
                );
            border-radius: 1px;
        }
        
        .stains {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse 35px 25px at 18% 28%, rgba(139, 69, 19, 0.12) 40%, rgba(101, 67, 33, 0.08) 60%, transparent 80%),
                radial-gradient(ellipse 25px 18px at 83% 72%, rgba(160, 82, 45, 0.09) 35%, rgba(139, 69, 19, 0.06) 55%, transparent 75%),
                radial-gradient(ellipse 40px 30px at 62% 12%, rgba(101, 67, 33, 0.06) 30%, rgba(160, 82, 45, 0.04) 50%, transparent 70%),
                radial-gradient(ellipse 8px 12px at 35% 45%, rgba(25, 25, 112, 0.08) 50%, transparent 70%),
                radial-gradient(ellipse 6px 8px at 75% 85%, rgba(72, 61, 139, 0.06) 40%, transparent 60%),
                radial-gradient(ellipse 60px 20px at 50% 95%, rgba(139, 69, 19, 0.05) 20%, transparent 50%),
                radial-gradient(ellipse 40px 15px at 20% 5%, rgba(160, 82, 45, 0.04) 30%, transparent 60%);
            mix-blend-mode: multiply;
        }
        
        .binding {
            position: absolute;
            left: 0;
            top: 0;
            width: 20px;
            height: 100%;
            background: 
                linear-gradient(to right, 
                    rgba(139, 69, 19, 0.1) 0%, 
                    rgba(160, 82, 45, 0.08) 50%, 
                    transparent 100%
                );
            border-right: 1px solid rgba(139, 69, 19, 0.2);
        }
        
        .binding::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 10%;
            width: 4px;
            height: 80%;
            background: 
                repeating-linear-gradient(
                    to bottom,
                    rgba(139, 69, 19, 0.3) 0px,
                    rgba(139, 69, 19, 0.3) 15px,
                    transparent 15px,
                    transparent 25px
                );
            border-radius: 2px;
        }
        
        canvas {
            display: block;
            margin: 30px auto;
            background: transparent;
            border-radius: 4px;
        }
        
        .pencil {
            position: absolute;
            width: 140px;
            height: 10px;
            background: 
                linear-gradient(90deg, 
                    #8b4513 0%, 
                    #d4af37 15%, 
                    #ffd700 50%, 
                    #d4af37 85%, 
                    #8b4513 100%
                );
            border-radius: 5px;
            transform-origin: 100% 50%;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 
                0 3px 6px rgba(0,0,0,0.3),
                inset 0 1px 2px rgba(255,255,255,0.4),
                inset 0 -1px 2px rgba(0,0,0,0.2);
        }
        
        .pencil::before {
            content: '';
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid #2c2c2c;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));
        }
        
        .pencil::after {
            content: '';
            position: absolute;
            left: 8px;
            top: 2px;
            width: 80px;
            height: 2px;
            background: 
                linear-gradient(90deg, 
                    rgba(255, 255, 255, 0.6) 0%, 
                    rgba(255, 255, 255, 0.4) 50%, 
                    rgba(255, 255, 255, 0.2) 100%
                );
            border-radius: 1px;
        }
        
        .pencil .eraser {
            position: absolute;
            left: -15px;
            top: 1px;
            width: 12px;
            height: 8px;
            background: 
                linear-gradient(90deg, 
                    #ff69b4 0%, 
                    #ff1493 50%, 
                    #dc143c 100%
                );
            border-radius: 2px;
            border: 1px solid #b8860b;
        }
        
        .page-fold {
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 30px;
            background: 
                linear-gradient(225deg, 
                    rgba(139, 69, 19, 0.1) 0%, 
                    rgba(160, 82, 45, 0.08) 50%, 
                    transparent 100%
                );
            clip-path: polygon(100% 0%, 0% 100%, 100% 100%);
            box-shadow: inset -2px 2px 4px rgba(0,0,0,0.1);
        }
        
        @keyframes paperShimmer {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.7; }
        }
        
        @media (max-width: 480px) {
            .container {
                width: 320px;
                height: 560px;
                margin: 20px;
            }
        }
        
        @media (max-height: 700px) {
            .container {
                height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="paper-texture"></div>
        <div class="book-lines"></div>
        <div class="margin-line"></div>
        <div class="stains"></div>
        <canvas id="drawingCanvas" width="320" height="580"></canvas>
        <div class="pencil" id="pencil">
            <div class="eraser"></div>
        </div>
        <div class="page-fold"></div>
    </div>

    <script>
        class PineappleHouseAnimator {
            constructor(canvasId, pencilId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.pencil = document.getElementById(pencilId);
                
                this.animationId = null;
                this.currentPhase = 0;
                this.progress = 0;
                this.isAnimating = false;
                this.startTime = null;
                
                this.config = {
                    phases: [
                        { name: 'sketch', duration: 6000, color: '#888', lineWidth: 1.5, opacity: 0.6, style: 'rough' },
                        { name: 'refine', duration: 4000, color: '#555', lineWidth: 2, opacity: 0.8, style: 'smooth' },
                        { name: 'ink', duration: 3000, color: '#222', lineWidth: 2.5, opacity: 1, style: 'precise' },
                        { name: 'color', duration: 7000, color: 'multicolor', lineWidth: 0, opacity: 1, style: 'fill' },
                        { name: 'highlight', duration: 2000, color: 'effects', lineWidth: 0, opacity: 1, style: 'effects' },
                        { name: 'pause', duration: 2000, color: 'transparent', lineWidth: 0, opacity: 1, style: 'none' }
                    ],
                    easing: {
                        easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
                        easeOutBounce: t => {
                            if (t < 1 / 2.75) return 7.5625 * t * t;
                            if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
                            if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
                            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
                        }
                    }
                };
                
                this.structure = this.initializeStructure();
                this.colors = this.initializeColors();
                
                this.setupCanvas();
                this.bindEvents();
            }
            
            initializeStructure() {
                return {
                    // Pineapple body (main oval shape)
                    pineappleBody: {
                        points: [
                            [160, 200], [140, 220], [120, 250], [110, 280], [105, 320], 
                            [110, 360], [120, 400], [140, 430], [160, 440], [180, 430], 
                            [200, 400], [210, 360], [215, 320], [210, 280], [200, 250], 
                            [180, 220], [160, 200]
                        ],
                        closed: true,
                        priority: 1,
                        smooth: true
                    },
                    
                    // Pineapple cross-hatch pattern (horizontal lines)
                    crossHatch1: {
                        points: [[125, 240], [195, 240]],
                        closed: false,
                        priority: 2
                    },
                    crossHatch2: {
                        points: [[120, 270], [200, 270]],
                        closed: false,
                        priority: 3
                    },
                    crossHatch3: {
                        points: [[115, 300], [205, 300]],
                        closed: false,
                        priority: 4
                    },
                    crossHatch4: {
                        points: [[118, 330], [202, 330]],
                        closed: false,
                        priority: 5
                    },
                    crossHatch5: {
                        points: [[122, 360], [198, 360]],
                        closed: false,
                        priority: 6
                    },
                    crossHatch6: {
                        points: [[130, 390], [190, 390]],
                        closed: false,
                        priority: 7
                    },
                    crossHatch7: {
                        points: [[140, 420], [180, 420]],
                        closed: false,
                        priority: 8
                    },
                    
                    // Diagonal lines (left to right)
                    diagonal1: {
                        points: [[135, 220], [160, 260], [180, 300], [190, 340], [185, 380]],
                        closed: false,
                        priority: 9
                    },
                    diagonal2: {
                        points: [[155, 210], [175, 250], [195, 290], [205, 330], [200, 370], [190, 410]],
                        closed: false,
                        priority: 10
                    },
                    diagonal3: {
                        points: [[175, 220], [195, 260], [210, 300], [210, 340], [205, 380]],
                        closed: false,
                        priority: 11
                    },
                    
                    // Diagonal lines (right to left)
                    diagonal4: {
                        points: [[185, 220], [160, 260], [140, 300], [130, 340], [135, 380]],
                        closed: false,
                        priority: 12
                    },
                    diagonal5: {
                        points: [[165, 210], [145, 250], [125, 290], [115, 330], [120, 370], [130, 410]],
                        closed: false,
                        priority: 13
                    },
                    diagonal6: {
                        points: [[145, 220], [125, 260], [110, 300], [110, 340], [115, 380]],
                        closed: false,
                        priority: 14
                    },
                    
                    // Pineapple leaves (crown)
                    leaf1: {
                        points: [[160, 200], [158, 180], [155, 160], [150, 140], [145, 120], [140, 100]],
                        closed: false,
                        priority: 15,
                        smooth: true
                    },
                    leaf2: {
                        points: [[160, 200], [165, 175], [170, 150], [175, 125], [180, 100], [185, 75]],
                        closed: false,
                        priority: 16,
                        smooth: true
                    },
                    leaf3: {
                        points: [[160, 200], [155, 175], [150, 150], [145, 125], [140, 100], [135, 75]],
                        closed: false,
                        priority: 17,
                        smooth: true
                    },
                    leaf4: {
                        points: [[160, 200], [170, 175], [180, 150], [190, 125], [200, 100], [210, 75]],
                        closed: false,
                        priority: 18,
                        smooth: true
                    },
                    leaf5: {
                        points: [[160, 200], [150, 175], [140, 150], [130, 125], [120, 100], [110, 75]],
                        closed: false,
                        priority: 19,
                        smooth: true
                    },
                    leaf6: {
                        points: [[160, 200], [175, 175], [190, 150], [205, 125], [220, 100], [235, 75]],
                        closed: false,
                        priority: 20,
                        smooth: true
                    },
                    leaf7: {
                        points: [[160, 200], [145, 175], [130, 150], [115, 125], [100, 100], [85, 75]],
                        closed: false,
                        priority: 21,
                        smooth: true
                    },
                    
                    // Door
                    door: {
                        points: [[140, 440], [140, 380], [180, 380], [180, 440]],
                        closed: false,
                        priority: 22
                    },
                    
                    // Door arch
                    doorArch: {
                        points: [[140, 380], [150, 370], [160, 365], [170, 370], [180, 380]],
                        closed: false,
                        priority: 23,
                        smooth: true
                    },
                    
                    // Windows
                    leftWindow: {
                        points: [[130, 320], [130, 290], [145, 290], [145, 320]],
                        closed: true,
                        priority: 24
                    },
                    rightWindow: {
                        points: [[175, 320], [175, 290], [190, 290], [190, 320]],
                        closed: true,
                        priority: 25
                    },
                    
                    // Window frames
                    leftWindowFrame: {
                        points: [[137.5, 290], [137.5, 320]],
                        closed: false,
                        priority: 26
                    },
                    rightWindowFrame: {
                        points: [[182.5, 290], [182.5, 320]],
                        closed: false,
                        priority: 27
                    },
                    
                    // Ground line
                    ground: {
                        points: [[0, 450], [320, 450]],
                        closed: false,
                        priority: 28
                    }
                };
            }
            
            initializeColors() {
                return {
                    background: {
                        sky: '#87CEEB',
                        ground: '#F5DEB3'
                    },
                    pineapple: {
                        body: '#FFA500',
                        bodyGradient: {
                            start: '#FFD700',
                            middle: '#FFA500',
                            end: '#FF6347'
                        },
                        crossHatch: '#D2691E',
                        leaves: '#228B22',
                        leafGradient: {
                            start: '#7CFC00',
                            middle: '#32CD32',
                            end: '#228B22'
                        }
                    },
                    door: {
                        primary: '#8B4513',
                        secondary: '#A0522D',
                        arch: '#654321'
                    },
                    windows: {
                        glass: '#87CEEB',
                        frame: '#8B4513'
                    },
                    effects: {
                        bubbles: 'rgba(255, 255, 255, 0.6)',
                        highlights: 'rgba(255, 255, 255, 0.8)',
                        shadows: 'rgba(0, 0, 0, 0.2)'
                    }
                };
            }
            
            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = this.canvas.getBoundingClientRect();
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            }
            
            bindEvents() {
                window.addEventListener('resize', this.debounce(() => this.setupCanvas(), 250));
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pause();
                    } else {
                        this.resume();
                    }
                });
            }
            
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
            
            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            drawBackground() {
                // Sky gradient
                const skyGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height * 0.8);
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(0.5, '#4169E1');
                skyGradient.addColorStop(1, '#1E90FF');
                
                this.ctx.fillStyle = skyGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height * 0.8);
                
                // Ground
                const groundGradient = this.ctx.createLinearGradient(0, this.canvas.height * 0.8, 0, this.canvas.height);
                groundGradient.addColorStop(0, '#F5DEB3');
                groundGradient.addColorStop(1, '#DEB887');
                
                this.ctx.fillStyle = groundGradient;
                this.ctx.fillRect(0, this.canvas.height * 0.8, this.canvas.width, this.canvas.height * 0.2);
                
                // Animated bubbles
                this.drawBubbles();
            }
            
            drawBubbles() {
                const bubbleCount = 8;
                const time = Date.now() * 0.001;
                
                this.ctx.fillStyle = this.colors.effects.bubbles;
                
                for (let i = 0; i < bubbleCount; i++) {
                    const x = (i * 40 + Math.sin(time + i) * 15) % this.canvas.width;
                    const y = Math.sin(time * 0.6 + i * 0.7) * this.canvas.height * 0.3 + this.canvas.height * 0.2;
                    const radius = Math.sin(time + i) * 1.5 + 2;
                    const opacity = (Math.sin(time * 0.4 + i) + 1) * 0.15 + 0.1;
                    
                    this.ctx.globalAlpha = opacity;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.globalAlpha = 1;
            }
            
            drawSmoothPath(points, closed = false) {
                if (points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(points[0][0], points[0][1]);
                
                if (points.length === 2) {
                    this.ctx.lineTo(points[1][0], points[1][1]);
                } else {
                    for (let i = 1; i < points.length - 1; i++) {
                        const xc = (points[i][0] + points[i + 1][0]) / 2;
                        const yc = (points[i][1] + points[i + 1][1]) / 2;
                        this.ctx.quadraticCurveTo(points[i][0], points[i][1], xc, yc);
                    }
                    
                    if (closed) {
                        const xc = (points[points.length - 1][0] + points[0][0]) / 2;
                        const yc = (points[points.length - 1][1] + points[0][1]) / 2;
                        this.ctx.quadraticCurveTo(points[points.length - 1][0], points[points.length - 1][1], xc, yc);
                        this.ctx.quadraticCurveTo(points[0][0], points[0][1], points[0][0], points[0][1]);
                    } else {
                        this.ctx.lineTo(points[points.length - 1][0], points[points.length - 1][1]);
                    }
                }
                
                if (closed) {
                    this.ctx.closePath();
                }
            }
            
            drawRoughPath(points, closed = false) {
                if (points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(points[0][0] + Math.random() * 2 - 1, points[0][1] + Math.random() * 2 - 1);
                
                for (let i = 1; i < points.length; i++) {
                    const jitterX = Math.random() * 1.5 - 0.75;
                    const jitterY = Math.random() * 1.5 - 0.75;
                    this.ctx.lineTo(points[i][0] + jitterX, points[i][1] + jitterY);
                }
                
                if (closed) {
                    this.ctx.closePath();
                }
            }
            
            drawPrecisePath(points, closed = false) {
                if (points.length < 2) return;
                
                this.ctx.beginPath();
                this.ctx.moveTo(points[0][0], points[0][1]);
                
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i][0], points[i][1]);
                }
                
                if (closed) {
                    this.ctx.closePath();
                }
            }
            
            fillShape(elementKey, progress) {
                const element = this.structure[elementKey];
                if (!element || !element.points) return;
                
                this.ctx.save();
                
                if (elementKey === 'pineappleBody') {
                    const gradient = this.ctx.createRadialGradient(160, 320, 20, 160, 320, 120);
                    gradient.addColorStop(0, this.colors.pineapple.bodyGradient.start);
                    gradient.addColorStop(0.5, this.colors.pineapple.bodyGradient.middle);
                    gradient.addColorStop(1, this.colors.pineapple.bodyGradient.end);
                    this.ctx.fillStyle = gradient;
                } else if (elementKey.includes('leaf')) {
                    const gradient = this.ctx.createLinearGradient(0, 75, 0, 200);
                    gradient.addColorStop(0, this.colors.pineapple.leafGradient.start);
                    gradient.addColorStop(0.5, this.colors.pineapple.leafGradient.middle);
                    gradient.addColorStop(1, this.colors.pineapple.leafGradient.end);
                    this.ctx.fillStyle = gradient;
                } else if (elementKey === 'door' || elementKey === 'doorArch') {
                    this.ctx.fillStyle = this.colors.door.primary;
                } else if (elementKey.includes('Window')) {
                    if (elementKey.includes('Frame')) {
                        this.ctx.fillStyle = this.colors.windows.frame;
                    } else {
                        this.ctx.fillStyle = this.colors.windows.glass;
                    }
                } else {
                    this.ctx.fillStyle = this.colors.pineapple.crossHatch;
                }
                
                this.drawSmoothPath(element.points, element.closed);
                this.ctx.fill();
                
                this.ctx.restore();
            }
            
            addEffects() {
                // Add sparkles around the pineapple
                const sparkleCount = 12;
                const time = Date.now() * 0.002;
                
                this.ctx.fillStyle = this.colors.effects.highlights;
                
                for (let i = 0; i < sparkleCount; i++) {
                    const angle = (i / sparkleCount) * Math.PI * 2 + time;
                    const radius = 140 + Math.sin(time * 2 + i) * 20;
                    const x = 160 + Math.cos(angle) * radius;
                    const y = 320 + Math.sin(angle) * radius * 0.8;
                    const size = Math.sin(time * 3 + i) * 1.5 + 1;
                    const opacity = (Math.sin(time * 1.5 + i) + 1) * 0.3 + 0.2;
                    
                    this.ctx.globalAlpha = opacity;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw sparkle rays
                    this.ctx.strokeStyle = this.colors.effects.highlights;
                    this.ctx.lineWidth = 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - size * 2, y);
                    this.ctx.lineTo(x + size * 2, y);
                    this.ctx.moveTo(x, y - size * 2);
                    this.ctx.lineTo(x, y + size * 2);
                    this.ctx.stroke();
                }
                
                this.ctx.globalAlpha = 1;
                
                // Add glow effect to the pineapple
                this.ctx.save();
                this.ctx.shadowColor = '#FFD700';
                this.ctx.shadowBlur = 15;
                this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                this.ctx.lineWidth = 3;
                this.drawSmoothPath(this.structure.pineappleBody.points, true);
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            updatePencilPosition(elementKey, pointIndex, totalPoints) {
                if (!this.structure[elementKey] || !this.structure[elementKey].points[pointIndex]) return;
                
                const point = this.structure[elementKey].points[pointIndex];
                const progress = pointIndex / Math.max(totalPoints - 1, 1);
                
                this.pencil.style.left = (point[0] - 70) + 'px';
                this.pencil.style.top = (point[1] - 5) + 'px';
                this.pencil.style.opacity = '0.8';
                
                // Rotate pencil based on drawing direction
                if (pointIndex > 0) {
                    const prevPoint = this.structure[elementKey].points[pointIndex - 1];
                    const angle = Math.atan2(point[1] - prevPoint[1], point[0] - prevPoint[0]);
                    this.pencil.style.transform = `rotate(${angle}rad)`;
                }
            }
            
            drawElement(elementKey, progress, phase) {
                const element = this.structure[elementKey];
                if (!element) return;
                
                const config = this.config.phases[phase];
                const totalPoints = element.points.length;
                const pointsToShow = Math.floor(progress * totalPoints);
                
                if (pointsToShow < 1) return;
                
                const partialPoints = element.points.slice(0, pointsToShow);
                
                if (partialPoints.length > 0) {
                    this.ctx.save();
                    this.ctx.globalAlpha = config.opacity;
                    this.ctx.strokeStyle = config.color === 'multicolor' ? this.getElementColor(elementKey) : config.color;
                    this.ctx.lineWidth = config.lineWidth;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    
                    if (config.style === 'fill' && progress > 0.8) {
                        this.fillShape(elementKey, progress);
                    } else if (config.lineWidth > 0) {
                        switch(config.style) {
                            case 'rough':
                                this.drawRoughPath(partialPoints, element.closed && progress > 0.95);
                                break;
                            case 'smooth':
                                if (element.smooth) {
                                    this.drawSmoothPath(partialPoints, element.closed && progress > 0.95);
                                } else {
                                    this.drawPrecisePath(partialPoints, element.closed && progress > 0.95);
                                }
                                break;
                            case 'precise':
                                this.drawPrecisePath(partialPoints, element.closed && progress > 0.95);
                                break;
                        }
                        this.ctx.stroke();
                    }
                    
                    this.ctx.restore();
                    
                    // Update pencil position
                    if (phase < 3 && pointsToShow > 0) {
                        this.updatePencilPosition(elementKey, Math.min(pointsToShow - 1, totalPoints - 1), totalPoints);
                    }
                }
            }
            
            getElementColor(elementKey) {
                if (elementKey === 'pineappleBody') return this.colors.pineapple.body;
                if (elementKey.includes('leaf')) return this.colors.pineapple.leaves;
                if (elementKey.includes('crossHatch') || elementKey.includes('diagonal')) return this.colors.pineapple.crossHatch;
                if (elementKey === 'door' || elementKey === 'doorArch') return this.colors.door.primary;
                if (elementKey.includes('Window')) {
                    return elementKey.includes('Frame') ? this.colors.windows.frame : this.colors.windows.glass;
                }
                return '#333';
            }
            
            animate(timestamp) {
                if (!this.startTime) this.startTime = timestamp;
                const elapsed = timestamp - this.startTime;
                
                // Clear canvas and draw background
                this.clearCanvas();
                this.drawBackground();
                
                // Calculate current phase and progress
                let totalElapsed = 0;
                let currentPhase = 0;
                
                for (let i = 0; i < this.config.phases.length; i++) {
                    if (elapsed >= totalElapsed && elapsed < totalElapsed + this.config.phases[i].duration) {
                        currentPhase = i;
                        this.progress = (elapsed - totalElapsed) / this.config.phases[i].duration;
                        break;
                    }
                    totalElapsed += this.config.phases[i].duration;
                }
                
                // If animation is complete, restart
                if (elapsed >= totalElapsed) {
                    this.startTime = timestamp;
                    return;
                }
                
                this.currentPhase = currentPhase;
                
                // Apply easing
                const easedProgress = this.config.easing.easeInOutCubic(this.progress);
                
                // Get elements sorted by priority
                const sortedElements = Object.keys(this.structure).sort((a, b) => {
                    return this.structure[a].priority - this.structure[b].priority;
                });
                
                // Draw elements for current and previous phases
                for (let phase = 0; phase <= currentPhase; phase++) {
                    const phaseProgress = phase === currentPhase ? easedProgress : 1;
                    
                    sortedElements.forEach(elementKey => {
                        if (phase < 3) { // Drawing phases
                            this.drawElement(elementKey, phaseProgress, phase);
                        } else if (phase === 3) { // Coloring phase
                            this.drawElement(elementKey, 1, 2); // Draw outline first
                            if (phaseProgress > 0.1) {
                                this.drawElement(elementKey, phaseProgress, phase);
                            }
                        } else if (phase === 4 && phaseProgress > 0.5) { // Effects phase
                            this.drawElement(elementKey, 1, 3); // Show colored version
                            this.addEffects();
                        } else {
                            this.drawElement(elementKey, 1, Math.min(phase, 3));
                        }
                    });
                }
                
                // Hide pencil during color and effects phases
                if (currentPhase >= 3) {
                    this.pencil.style.opacity = '0';
                }
                
                // Continue animation
                if (this.isAnimating) {
                    this.animationId = requestAnimationFrame(this.animate.bind(this));
                }
            }
            
            start() {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                this.startTime = null;
                this.animationId = requestAnimationFrame(this.animate.bind(this));
            }
            
            stop() {
                this.isAnimating = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                this.pencil.style.opacity = '0';
            }
            
            pause() {
                if (this.isAnimating) {
                    this.isAnimating = false;
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                    }
                }
            }
            
            resume() {
                if (!this.isAnimating && this.animationId !== null) {
                    this.isAnimating = true;
                    this.animationId = requestAnimationFrame(this.animate.bind(this));
                }
            }
        }
        
        // Initialize the animation when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const animator = new PineappleHouseAnimator('drawingCanvas', 'pencil');
            
            // Auto-start the animation
            setTimeout(() => {
                animator.start();
            }, 1000);
            
            // Add click to restart functionality
            document.addEventListener('click', () => {
                animator.stop();
                setTimeout(() => {
                    animator.start();
                }, 100);
            });
            
            // Handle window focus/blur for performance
            window.addEventListener('focus', () => {
                animator.resume();
            });
            
            window.addEventListener('blur', () => {
                animator.pause();
            });
        });
    </script>
</body>
</html>
