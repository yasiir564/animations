<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batman Drawing Animation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f5f5dc 0%, #e8e8e8 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        .container {
            width: 360px;
            height: 640px;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255,255,255,0.1) 1px, transparent 1px),
                radial-gradient(circle at 80% 70%, rgba(0,0,0,0.02) 1px, transparent 1px),
                linear-gradient(135deg, #fafafa 0%, #f0f0f0 100%);
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.1),
                inset 0 1px 0 rgba(255,255,255,0.8);
            position: relative;
            overflow: hidden;
        }
        
        .paper-texture {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.3;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 20px,
                    rgba(0,0,0,0.02) 21px,
                    rgba(0,0,0,0.02) 22px
                );
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .pencil {
            position: absolute;
            width: 120px;
            height: 12px;
            z-index: 10;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .pencil-body {
            width: 100px;
            height: 8px;
            background: linear-gradient(to right, #d4af37 0%, #ffd700 50%, #d4af37 100%);
            border-radius: 4px;
            position: relative;
        }
        
        .pencil-tip {
            width: 20px;
            height: 8px;
            background: linear-gradient(to right, #8b4513, #d2691e);
            border-radius: 0 4px 4px 0;
            position: absolute;
            right: -20px;
            top: 0;
        }
        
        .pencil-point {
            width: 0;
            height: 0;
            border-left: 8px solid #2c2c2c;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            position: absolute;
            right: -28px;
            top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="paper-texture"></div>
        <div class="pencil" id="pencil">
            <div class="pencil-body"></div>
            <div class="pencil-tip"></div>
            <div class="pencil-point"></div>
        </div>
        <canvas id="canvas" width="360" height="640"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const pencil = document.getElementById('pencil');

let animationStep = 0;
let particles = [];
let sparkles = [];
let shakeOffset = { x: 0, y: 0 };

// Enhanced Batman drawing coordinates with more detail
const batmanPaths = [
    // Head outline with more curves
    [{x: 180, y: 120}, {x: 185, y: 115}, {x: 195, y: 112}, {x: 205, y: 115}, {x: 215, y: 120}, {x: 225, y: 130}, {x: 230, y: 140}, {x: 228, y: 150}, {x: 225, y: 160}, {x: 220, y: 170}, {x: 210, y: 180}, {x: 195, y: 185}, {x: 180, y: 186}, {x: 165, y: 185}, {x: 150, y: 180}, {x: 140, y: 170}, {x: 135, y: 160}, {x: 132, y: 150}, {x: 130, y: 140}, {x: 135, y: 130}, {x: 145, y: 120}, {x: 155, y: 115}, {x: 165, y: 112}, {x: 175, y: 115}, {x: 180, y: 120}],
    
    // Left bat ear with detail
    [{x: 160, y: 110}, {x: 158, y: 105}, {x: 155, y: 95}, {x: 152, y: 85}, {x: 150, y: 75}, {x: 155, y: 70}, {x: 162, y: 75}, {x: 165, y: 82}, {x: 168, y: 90}, {x: 170, y: 100}, {x: 165, y: 108}],
    
    // Right bat ear with detail
    [{x: 200, y: 110}, {x: 202, y: 105}, {x: 205, y: 95}, {x: 208, y: 85}, {x: 210, y: 75}, {x: 205, y: 70}, {x: 198, y: 75}, {x: 195, y: 82}, {x: 192, y: 90}, {x: 190, y: 100}, {x: 195, y: 108}],
    
    // Left eye with detail
    [{x: 158, y: 135}, {x: 165, y: 132}, {x: 172, y: 135}, {x: 175, y: 142}, {x: 172, y: 148}, {x: 165, y: 150}, {x: 158, y: 148}, {x: 155, y: 142}, {x: 158, y: 135}],
    // Left pupil
    [{x: 162, y: 140}, {x: 168, y: 142}, {x: 165, y: 145}, {x: 162, y: 143}],
    
    // Right eye with detail
    [{x: 188, y: 135}, {x: 195, y: 132}, {x: 202, y: 135}, {x: 205, y: 142}, {x: 202, y: 148}, {x: 195, y: 150}, {x: 188, y: 148}, {x: 185, y: 142}, {x: 188, y: 135}],
    // Right pupil
    [{x: 192, y: 140}, {x: 198, y: 142}, {x: 195, y: 145}, {x: 192, y: 143}],
    
    // Nose bridge
    [{x: 180, y: 150}, {x: 182, y: 155}, {x: 180, y: 158}, {x: 178, y: 155}],
    
    // Mouth area
    [{x: 175, y: 165}, {x: 180, y: 168}, {x: 185, y: 165}, {x: 182, y: 170}, {x: 180, y: 172}, {x: 178, y: 170}],
    
    // Jawline definition
    [{x: 145, y: 175}, {x: 155, y: 180}, {x: 170, y: 182}, {x: 180, y: 183}, {x: 190, y: 182}, {x: 205, y: 180}, {x: 215, y: 175}],
    
    // Cape collar
    [{x: 120, y: 200}, {x: 130, y: 195}, {x: 140, y: 190}, {x: 160, y: 188}, {x: 180, y: 185}, {x: 200, y: 188}, {x: 220, y: 190}, {x: 230, y: 195}, {x: 240, y: 200}],
    
    // Shoulder structure
    [{x: 140, y: 210}, {x: 150, y: 205}, {x: 160, y: 200}, {x: 170, y: 202}, {x: 180, y: 205}, {x: 190, y: 202}, {x: 200, y: 200}, {x: 210, y: 205}, {x: 220, y: 210}],
    
    // Chest definition
    [{x: 150, y: 230}, {x: 160, y: 225}, {x: 170, y: 220}, {x: 180, y: 225}, {x: 190, y: 220}, {x: 200, y: 225}, {x: 210, y: 230}],
    
    // Enhanced bat symbol
    [{x: 180, y: 240}, {x: 175, y: 242}, {x: 170, y: 245}, {x: 165, y: 250}, {x: 168, y: 252}, {x: 172, y: 254}, {x: 175, y: 255}, {x: 180, y: 250}, {x: 185, y: 255}, {x: 188, y: 254}, {x: 192, y: 252}, {x: 195, y: 250}, {x: 190, y: 245}, {x: 185, y: 242}, {x: 180, y: 240}],
    
    // Bat symbol wings
    [{x: 165, y: 250}, {x: 160, y: 248}, {x: 155, y: 252}, {x: 158, y: 255}, {x: 165, y: 253}],
    [{x: 195, y: 250}, {x: 200, y: 248}, {x: 205, y: 252}, {x: 202, y: 255}, {x: 195, y: 253}],
    
    // Left arm with muscle definition
    [{x: 140, y: 210}, {x: 135, y: 220}, {x: 130, y: 235}, {x: 125, y: 250}, {x: 120, y: 265}, {x: 115, y: 280}, {x: 112, y: 295}, {x: 115, y: 300}],
    [{x: 125, y: 240}, {x: 128, y: 245}, {x: 125, y: 250}, {x: 122, y: 255}],
    
    // Right arm with muscle definition
    [{x: 220, y: 210}, {x: 225, y: 220}, {x: 230, y: 235}, {x: 235, y: 250}, {x: 240, y: 265}, {x: 245, y: 280}, {x: 248, y: 295}, {x: 245, y: 300}],
    [{x: 235, y: 240}, {x: 232, y: 245}, {x: 235, y: 250}, {x: 238, y: 255}],
    
    // Torso left side with ab definition
    [{x: 150, y: 280}, {x: 155, y: 300}, {x: 160, y: 320}, {x: 165, y: 340}, {x: 170, y: 360}, {x: 175, y: 380}, {x: 180, y: 400}],
    [{x: 155, y: 290}, {x: 158, y: 295}, {x: 155, y: 300}],
    [{x: 160, y: 310}, {x: 163, y: 315}, {x: 160, y: 320}],
    
    // Torso right side with ab definition
    [{x: 210, y: 280}, {x: 205, y: 300}, {x: 200, y: 320}, {x: 195, y: 340}, {x: 190, y: 360}, {x: 185, y: 380}, {x: 180, y: 400}],
    [{x: 205, y: 290}, {x: 202, y: 295}, {x: 205, y: 300}],
    [{x: 200, y: 310}, {x: 197, y: 315}, {x: 200, y: 320}],
    
    // Belt
    [{x: 150, y: 350}, {x: 165, y: 348}, {x: 180, y: 350}, {x: 195, y: 348}, {x: 210, y: 350}],
    [{x: 175, y: 350}, {x: 180, y: 355}, {x: 185, y: 350}],
    
    // Cape left side with flowing curves
    [{x: 120, y: 200}, {x: 110, y: 220}, {x: 105, y: 240}, {x: 100, y: 265}, {x: 95, y: 290}, {x: 90, y: 320}, {x: 88, y: 350}, {x: 90, y: 380}, {x: 95, y: 410}, {x: 105, y: 440}, {x: 110, y: 470}, {x: 120, y: 500}, {x: 130, y: 520}],
    
    // Cape right side with flowing curves
    [{x: 240, y: 200}, {x: 250, y: 220}, {x: 255, y: 240}, {x: 260, y: 265}, {x: 265, y: 290}, {x: 270, y: 320}, {x: 272, y: 350}, {x: 270, y: 380}, {x: 265, y: 410}, {x: 255, y: 440}, {x: 250, y: 470}, {x: 240, y: 500}, {x: 230, y: 520}],
    
    // Cape bottom with dramatic curves
    [{x: 130, y: 520}, {x: 140, y: 535}, {x: 150, y: 545}, {x: 165, y: 540}, {x: 180, y: 530}, {x: 195, y: 540}, {x: 210, y: 545}, {x: 220, y: 535}, {x: 230, y: 520}],
    
    // Cape interior folds
    [{x: 120, y: 250}, {x: 125, y: 280}, {x: 130, y: 320}, {x: 128, y: 360}, {x: 135, y: 400}],
    [{x: 240, y: 250}, {x: 235, y: 280}, {x: 230, y: 320}, {x: 232, y: 360}, {x: 225, y: 400}],
    
    // Utility belt details
    [{x: 155, y: 355}, {x: 158, y: 358}, {x: 155, y: 361}, {x: 152, y: 358}],
    [{x: 170, y: 357}, {x: 173, y: 360}, {x: 170, y: 363}, {x: 167, y: 360}],
    [{x: 190, y: 357}, {x: 193, y: 360}, {x: 190, y: 363}, {x: 187, y: 360}],
    [{x: 205, y: 355}, {x: 208, y: 358}, {x: 205, y: 361}, {x: 202, y: 358}]
];

// Particle system for drawing effects
class Particle {
    constructor(x, y, type = 'dust') {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 2;
        this.vy = (Math.random() - 0.5) * 2;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.02;
        this.size = Math.random() * 3 + 1;
        this.type = type;
        this.color = type === 'ink' ? '#000' : '#666';
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.vy += 0.1; // gravity
        this.vx *= 0.98; // friction
        return this.life > 0;
    }
    
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life * 0.6;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// Sparkle effect for magical touches
class Sparkle {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 4 + 2;
        this.life = 1;
        this.decay = 0.015;
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 0.2;
    }
    
    update() {
        this.life -= this.decay;
        this.rotation += this.rotationSpeed;
        this.size *= 0.995;
        return this.life > 0;
    }
    
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.life;
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        
        const size = this.size * this.life;
        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, size);
        ctx.moveTo(-size * 0.7, -size * 0.7);
        ctx.lineTo(size * 0.7, size * 0.7);
        ctx.moveTo(-size * 0.7, size * 0.7);
        ctx.lineTo(size * 0.7, -size * 0.7);
        ctx.stroke();
        ctx.restore();
    }
}

function drawPath(path, progress, style = 'sketch') {
    if (path.length < 2) return;
    
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Enhanced styling with shadows
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';
    
    if (style === 'sketch') {
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1.2 + Math.sin(Date.now() * 0.01) * 0.2; // Subtle width variation
        ctx.globalAlpha = 0.6;
        ctx.shadowBlur = 1;
        ctx.shadowColor = '#666';
    } else if (style === 'ink') {
        ctx.strokeStyle = '#1a1a1a';
        ctx.lineWidth = 2.8;
        ctx.globalAlpha = 0.9;
        ctx.shadowBlur = 2;
        ctx.shadowColor = '#000';
    } else if (style === 'color') {
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3.2;
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 3;
        ctx.shadowColor = '#333';
    }
    
    const totalPoints = path.length;
    const pointsToShow = Math.floor(totalPoints * progress);
    
    if (pointsToShow < 2) return;
    
    ctx.beginPath();
    ctx.moveTo(path[0].x + shakeOffset.x, path[0].y + shakeOffset.y);
    
    // Add slight hand tremor effect
    for (let i = 1; i < pointsToShow; i++) {
        const tremor = style === 'sketch' ? (Math.random() - 0.5) * 0.8 : 0;
        ctx.lineTo(
            path[i].x + shakeOffset.x + tremor, 
            path[i].y + shakeOffset.y + tremor
        );
    }
    
    // Smooth transition to next point
    if (pointsToShow < totalPoints) {
        const lastPoint = path[pointsToShow - 1];
        const nextPoint = path[pointsToShow];
        const partialProgress = (totalPoints * progress) - pointsToShow;
        
        const x = lastPoint.x + (nextPoint.x - lastPoint.x) * partialProgress;
        const y = lastPoint.y + (nextPoint.y - lastPoint.y) * partialProgress;
        
        ctx.lineTo(x + shakeOffset.x, y + shakeOffset.y);
        
        // Add particles while drawing
        if (Math.random() < 0.3) {
            particles.push(new Particle(x, y, style));
        }
    }
    
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function updatePencilPosition(path, progress) {
    if (!path || path.length < 2) return;
    
    const totalPoints = path.length;
    const currentIndex = Math.min(Math.floor(totalPoints * progress), totalPoints - 1);
    const nextIndex = Math.min(currentIndex + 1, totalPoints - 1);
    
    const current = path[currentIndex];
    const next = path[nextIndex];
    
    if (current && next) {
        const partialProgress = (totalPoints * progress) - currentIndex;
        const x = current.x + (next.x - current.x) * partialProgress;
        const y = current.y + (next.y - current.y) * partialProgress;
        
        // Enhanced pencil movement with smoother positioning
        pencil.style.left = (x - 60) + 'px';
        pencil.style.top = (y - 20) + 'px';
        pencil.style.opacity = '1';
        
        // Calculate angle for realistic pencil rotation
        const angle = Math.atan2(next.y - current.y, next.x - current.x);
        const degrees = angle * (180 / Math.PI);
        pencil.style.transform = `rotate(${degrees + 45}deg) scale(1.1)`;
        
        // Add subtle hand shake effect
        shakeOffset.x = Math.sin(Date.now() * 0.02) * 0.5;
        shakeOffset.y = Math.cos(Date.now() * 0.03) * 0.3;
        
        // Add sparkles occasionally
        if (Math.random() < 0.1) {
            sparkles.push(new Sparkle(x, y));
        }
    }
}

function updateAndDrawParticles() {
    particles = particles.filter(particle => {
        particle.update();
        particle.draw();
        return particle.life > 0;
    });
    
    sparkles = sparkles.filter(sparkle => {
        sparkle.update();
        sparkle.draw();
        return sparkle.life > 0;
    });
}

function addGradientBackground(phase) {
    const gradient = ctx.createRadialGradient(180, 300, 0, 180, 300, 400);
    
    if (phase === 0) { // Sketch phase
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(200, 200, 200, 0.02)');
    } else if (phase === 1) { // Ink phase
        gradient.addColorStop(0, 'rgba(50, 50, 50, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
    } else { // Color phase
        gradient.addColorStop(0, 'rgba(25, 25, 46, 0.15)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
    }
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function animate() {
    const phases = [
        { duration: 12000, style: 'sketch' },  // 12 seconds sketching
        { duration: 8000, style: 'ink' },     // 8 seconds inking
        { duration: 10000, style: 'color' }   // 10 seconds coloring
    ];
    
    const totalDuration = phases.reduce((sum, phase) => sum + phase.duration, 0);
    const startTime = Date.now();
    
    function frame() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / totalDuration, 1);
        
        // Clear canvas with enhanced background
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Determine current phase
        let currentPhase = 0;
        let phaseProgress = 0;
        let accumulatedTime = 0;
        
        for (let i = 0; i < phases.length; i++) {
            if (elapsed <= accumulatedTime + phases[i].duration) {
                currentPhase = i;
                phaseProgress = (elapsed - accumulatedTime) / phases[i].duration;
                break;
            }
            accumulatedTime += phases[i].duration;
        }
        
        // Add atmospheric background
        addGradientBackground(currentPhase);
        
        // Draw all previous phases completely
        for (let phase = 0; phase < currentPhase; phase++) {
            for (let i = 0; i < batmanPaths.length; i++) {
                drawPath(batmanPaths[i], 1, phases[phase].style);
            }
        }
        
        // Draw current phase progressively
        const pathsPerPhase = batmanPaths.length;
        const pathProgress = phaseProgress * pathsPerPhase;
        const currentPathIndex = Math.floor(pathProgress);
        const currentPathProgress = pathProgress - currentPathIndex;
        
        // Draw completed paths in current phase
        for (let i = 0; i < currentPathIndex && i < batmanPaths.length; i++) {
            drawPath(batmanPaths[i], 1, phases[currentPhase].style);
        }
        
        // Draw current path being drawn
        if (currentPathIndex < batmanPaths.length) {
            drawPath(batmanPaths[currentPathIndex], currentPathProgress, phases[currentPhase].style);
            updatePencilPosition(batmanPaths[currentPathIndex], currentPathProgress);
        }
        
        // Enhanced color fills in color phase
        if (currentPhase === 2) {
            ctx.globalAlpha = 0.85;
            
            // Cape with gradient
            const capeGradient = ctx.createLinearGradient(90, 200, 270, 520);
            capeGradient.addColorStop(0, '#1a1a2e');
            capeGradient.addColorStop(0.5, '#16213e');
            capeGradient.addColorStop(1, '#0f1419');
            
            ctx.fillStyle = capeGradient;
            ctx.beginPath();
            ctx.moveTo(120, 200);
            ctx.lineTo(100, 250);
            ctx.lineTo(90, 320);
            ctx.lineTo(95, 400);
            ctx.lineTo(110, 480);
            ctx.lineTo(130, 520);
            ctx.lineTo(180, 530);
            ctx.lineTo(230, 520);
            ctx.lineTo(250, 480);
            ctx.lineTo(265, 400);
            ctx.lineTo(270, 320);
            ctx.lineTo(260, 250);
            ctx.lineTo(240, 200);
            ctx.lineTo(220, 190);
            ctx.lineTo(180, 185);
            ctx.lineTo(140, 190);
            ctx.closePath();
            ctx.fill();
            
            // Suit with gradient
            const suitGradient = ctx.createLinearGradient(150, 230, 210, 400);
            suitGradient.addColorStop(0, '#2c2c2c');
            suitGradient.addColorStop(0.5, '#1a1a1a');
            suitGradient.addColorStop(1, '#0a0a0a');
            
            ctx.fillStyle = suitGradient;
            ctx.beginPath();
            ctx.moveTo(150, 230);
            ctx.lineTo(180, 225);
            ctx.lineTo(210, 230);
            ctx.lineTo(200, 320);
            ctx.lineTo(180, 400);
            ctx.lineTo(160, 320);
            ctx.closePath();
            ctx.fill();
            
            // Enhanced bat symbol with metallic effect
            const batGradient = ctx.createRadialGradient(180, 247, 0, 180, 247, 15);
            batGradient.addColorStop(0, '#333');
            batGradient.addColorStop(0.7, '#000');
            batGradient.addColorStop(1, '#111');
            
            ctx.fillStyle = batGradient;
            ctx.beginPath();
            ctx.moveTo(180, 240);
            ctx.lineTo(170, 245);
            ctx.lineTo(165, 250);
            ctx.lineTo(175, 255);
            ctx.lineTo(180, 250);
            ctx.lineTo(185, 255);
            ctx.lineTo(195, 250);
            ctx.lineTo(190, 245);
            ctx.closePath();
            ctx.fill();
            
            // Add highlight to bat symbol
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.arc(175, 245, 2, 0, Math.PI * 2);
            ctx.arc(185, 245, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Eyes with glow effect
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.ellipse(165, 142, 3, 4, 0, 0, Math.PI * 2);
            ctx.ellipse(195, 142, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.globalAlpha = 1;
        }
        
        // Update and draw particle effects
        updateAndDrawParticles();
        
        if (progress < 1) {
            requestAnimationFrame(frame);
        } else {
            // Epic finish with sparkle burst
            for (let i = 0; i < 20; i++) {
                sparkles.push(new Sparkle(
                    150 + Math.random() * 60,
                    200 + Math.random() * 200
                ));
            }
            
            // Hide pencil with smooth transition
            pencil.style.transition = 'opacity 1s ease-out';
            pencil.style.opacity = '0';
            
            // Restart animation after 3 seconds
            setTimeout(() => {
                pencil.style.transition = '';
                animate();
            }, 3000);
        }
    }
    
    requestAnimationFrame(frame);
}

// Enhanced startup with delay for dramatic effect
setTimeout(() => {
    // Add subtle entry effect to pencil
    pencil.style.transition = 'transform 0.5s ease-out';
    pencil.style.transform = 'scale(1.2)';
    setTimeout(() => {
        pencil.style.transform = 'scale(1)';
    }, 500);
    
    animate();
}, 800);
    </script>
</body>
</html>
