<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tom & Jerry Drawing Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #f5f5f5;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        .shorts-container {
            position: relative;
            width: 100%;
            max-width: 540px;
            height: 960px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .drawing-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            height: 80%;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .progress-bar {
            position: absolute;
            top: 10px;
            left: 10px;
            width: calc(100% - 20px);
            height: 4px;
            background-color: rgba(0, 0, 0, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress {
            height: 100%;
            width: 0%;
            background-color: #ff0000;
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        
        .timer {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #333;
            font-size: 14px;
            font-weight: bold;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 3px 8px;
            border-radius: 12px;
        }
        
        .step-indicator {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 8px 0;
            border-radius: 20px;
            margin: 0 auto;
            max-width: 200px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        @media (max-width: 540px) {
            .shorts-container {
                height: 100vh;
                width: 100vw;
                border-radius: 0;
            }
        }
    </style>
</head>
<body>
    <div class="shorts-container">
        <div class="progress-bar">
            <div class="progress" id="progress"></div>
        </div>
        <div class="timer" id="timer">0:00</div>
        <div class="step-indicator" id="stepIndicator">Starting...</div>
        
        <div class="drawing-container">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('drawingCanvas');
            const ctx = canvas.getContext('2d');
            const progress = document.getElementById('progress');
            const timer = document.getElementById('timer');
            const stepIndicator = document.getElementById('stepIndicator');
            
            // Set canvas size
            canvas.width = 540;
            canvas.height = 960;
            
            // Animation timing (30 seconds total)
            const totalDuration = 30000; // 30 seconds in milliseconds
            let startTime;
            
            // Drawing steps with their durations and colors
            const drawingSteps = [
                {
                    name: "Basic Outline",
                    duration: 8000,
                    color: "#333333",
                    lineWidth: 2,
                    paths: generateOutlinePaths()
                },
                {
                    name: "Detailed Sketch",
                    duration: 7000,
                    color: "#555555",
                    lineWidth: 1.5,
                    paths: generateDetailPaths()
                },
                {
                    name: "Base Colors",
                    duration: 8000,
                    color: "none",
                    fill: true,
                    paths: generateColorPaths()
                },
                {
                    name: "Shading & Highlights",
                    duration: 5000,
                    color: "none",
                    shading: true,
                    paths: generateShadingPaths()
                },
                {
                    name: "Final Touches",
                    duration: 2000,
                    color: "#000000",
                    lineWidth: 1,
                    final: true,
                    paths: generateFinalPaths()
                }
            ];
            
            // Start the animation
            function startAnimation() {
                startTime = performance.now();
                requestAnimationFrame(animate);
            }
            
            // Animation loop
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progressPercent = Math.min(elapsed / totalDuration, 1);
                
                // Update progress bar and timer
                progress.style.width = `${progressPercent * 100}%`;
                updateTimer(elapsed);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw paper texture
                drawPaperTexture();
                
                // Calculate current step
                let accumulatedTime = 0;
                let currentStep = null;
                let stepProgress = 0;
                
                for (let i = 0; i < drawingSteps.length; i++) {
                    if (elapsed >= accumulatedTime && elapsed < accumulatedTime + drawingSteps[i].duration) {
                        currentStep = drawingSteps[i];
                        stepProgress = (elapsed - accumulatedTime) / currentStep.duration;
                        stepIndicator.textContent = currentStep.name;
                        break;
                    }
                    accumulatedTime += drawingSteps[i].duration;
                }
                
                // If all steps are done, show final result
                if (!currentStep) {
                    drawAllSteps();
                    stepIndicator.textContent = "Finished!";
                    return;
                }
                
                // Draw up to the current step
                drawStepsUpTo(drawingSteps.indexOf(currentStep), stepProgress);
                
                // Continue animation if not finished
                if (progressPercent < 1) {
                    requestAnimationFrame(animate);
                }
            }
            
            // Draw all completed steps
            function drawStepsUpTo(stepIndex, progress) {
                for (let i = 0; i <= stepIndex; i++) {
                    const step = drawingSteps[i];
                    const isCurrentStep = i === stepIndex;
                    const paths = step.paths;
                    
                    if (step.fill) {
                        // Coloring step
                        for (let j = 0; j < paths.length; j++) {
                            const path = paths[j];
                            const drawUpTo = isCurrentStep ? Math.floor(progress * path.points.length) : path.points.length;
                            
                            ctx.fillStyle = path.color;
                            ctx.beginPath();
                            
                            // Draw the outline
                            for (let k = 0; k < path.outline.length; k++) {
                                const point = path.outline[k];
                                if (k === 0) {
                                    ctx.moveTo(point.x, point.y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            }
                            
                            // Fill if we're in this step or beyond
                            if (i < stepIndex || (isCurrentStep && drawUpTo > 0)) {
                                ctx.fill();
                            }
                        }
                    } else if (step.shading) {
                        // Shading step
                        for (let j = 0; j < paths.length; j++) {
                            const path = paths[j];
                            const drawUpTo = isCurrentStep ? Math.floor(progress * path.points.length) : path.points.length;
                            
                            for (let k = 0; k < drawUpTo; k++) {
                                const point = path.points[k];
                                ctx.fillStyle = path.color;
                                ctx.globalAlpha = path.alpha || 0.3;
                                ctx.beginPath();
                                ctx.arc(point.x, point.y, path.radius || 5, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.globalAlpha = 1;
                    } else {
                        // Drawing step
                        ctx.strokeStyle = step.color;
                        ctx.lineWidth = step.lineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        for (let j = 0; j < paths.length; j++) {
                            const path = paths[j];
                            const drawUpTo = isCurrentStep ? Math.floor(progress * path.points.length) : path.points.length;
                            
                            if (drawUpTo > 0) {
                                ctx.beginPath();
                                ctx.moveTo(path.points[0].x, path.points[0].y);
                                
                                for (let k = 1; k < drawUpTo; k++) {
                                    const point = path.points[k];
                                    ctx.lineTo(point.x, point.y);
                                }
                                
                                ctx.stroke();
                            }
                        }
                    }
                }
            }
            
            // Draw all steps (for final frame)
            function drawAllSteps() {
                drawStepsUpTo(drawingSteps.length - 1, 1);
            }
            
            // Update timer display
            function updateTimer(elapsed) {
                const seconds = Math.floor(elapsed / 1000);
                const remainingMs = elapsed % 1000;
                const displayMs = Math.floor(remainingMs / 100);
                timer.textContent = `${Math.floor(seconds / 60)}:${(seconds % 60).toString().padStart(2, '0')}.${displayMs}`;
            }
            
            // Draw paper texture
            function drawPaperTexture() {
                ctx.fillStyle = '#f9f9f5';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Subtle paper texture
                ctx.fillStyle = 'rgba(200, 200, 180, 0.02)';
                for (let i = 0; i < 200; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = Math.random() * 3 + 1;
                    ctx.fillRect(x, y, size, size);
                }
            }
            
            // Generate paths for outline step
            function generateOutlinePaths() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 1.8;
                
                // Simplified Tom & Jerry outline paths
                const paths = [];
                
                // Tom's head outline
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX - 50*scale, y: centerY - 20*scale},
                        {x: centerX - 80*scale, y: centerY - 10*scale},
                        {x: centerX - 90*scale, y: centerY + 20*scale},
                        {x: centerX - 80*scale, y: centerY + 50*scale},
                        {x: centerX - 60*scale, y: centerY + 70*scale},
                        {x: centerX - 30*scale, y: centerY + 80*scale},
                        {x: centerX + 10*scale, y: centerY + 70*scale},
                        {x: centerX + 40*scale, y: centerY + 50*scale},
                        {x: centerX + 60*scale, y: centerY + 20*scale},
                        {x: centerX + 60*scale, y: centerY - 20*scale},
                        {x: centerX + 40*scale, y: centerY - 40*scale},
                        {x: centerX + 10*scale, y: centerY - 50*scale},
                        {x: centerX - 30*scale, y: centerY - 40*scale},
                        {x: centerX - 50*scale, y: centerY - 20*scale}
                    ], 30)
                });
                
                // Tom's ears
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX - 60*scale, y: centerY - 30*scale},
                        {x: centerX - 70*scale, y: centerY - 50*scale},
                        {x: centerX - 90*scale, y: centerY - 60*scale},
                        {x: centerX - 80*scale, y: centerY - 40*scale},
                        {x: centerX - 70*scale, y: centerY - 30*scale}
                    ], 15)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX - 20*scale, y: centerY - 50*scale},
                        {x: centerX - 10*scale, y: centerY - 70*scale},
                        {x: centerX + 10*scale, y: centerY - 80*scale},
                        {x: centerX + 30*scale, y: centerY - 70*scale},
                        {x: centerX + 30*scale, y: centerY - 50*scale}
                    ], 15)
                });
                
                // Jerry's head outline
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 20*scale, y: centerY - 80*scale},
                        {x: centerX + 40*scale, y: centerY - 90*scale},
                        {x: centerX + 70*scale, y: centerY - 80*scale},
                        {x: centerX + 90*scale, y: centerY - 60*scale},
                        {x: centerX + 90*scale, y: centerY - 30*scale},
                        {x: centerX + 70*scale, y: centerY - 10*scale},
                        {x: centerX + 40*scale, y: centerY + 10*scale},
                        {x: centerX + 10*scale, y: centerY + 10*scale},
                        {x: centerX - 10*scale, y: centerY + 5*scale},
                        {x: centerX - 20*scale, y: centerY - 10*scale},
                        {x: centerX - 10*scale, y: centerY - 30*scale},
                        {x: centerX + 10*scale, y: centerY - 50*scale},
                        {x: centerX + 20*scale, y: centerY - 80*scale}
                    ], 30)
                });
                
                // Jerry's ears
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 30*scale, y: centerY - 90*scale},
                        {x: centerX + 20*scale, y: centerY - 110*scale},
                        {x: centerX + 40*scale, y: centerY - 120*scale},
                        {x: centerX + 60*scale, y: centerY - 110*scale},
                        {x: centerX + 50*scale, y: centerY - 90*scale}
                    ], 15)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 70*scale, y: centerY - 90*scale},
                        {x: centerX + 80*scale, y: centerY - 110*scale},
                        {x: centerX + 100*scale, y: centerY - 100*scale},
                        {x: centerX + 90*scale, y: centerY - 80*scale}
                    ], 12)
                });
                
                return paths;
            }
            
            // Generate paths for detail step
            function generateDetailPaths() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 1.8;
                
                const paths = [];
                
                // Tom's facial features
                // Eyes
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX - 30*scale, y: centerY - 10*scale},
                        {x: centerX - 20*scale, y: centerY - 15*scale},
                        {x: centerX - 10*scale, y: centerY - 10*scale},
                        {x: centerX - 15*scale, y: centerY - 5*scale},
                        {x: centerX - 25*scale, y: centerY - 5*scale},
                        {x: centerX - 30*scale, y: centerY - 10*scale}
                    ], 15)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 20*scale, y: centerY - 15*scale},
                        {x: centerX + 30*scale, y: centerY - 20*scale},
                        {x: centerX + 40*scale, y: centerY - 15*scale},
                        {x: centerX + 35*scale, y: centerY - 10*scale},
                        {x: centerX + 25*scale, y: centerY - 10*scale},
                        {x: centerX + 20*scale, y: centerY - 15*scale}
                    ], 15)
                });
                
                // Nose
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX, y: centerY},
                        {x: centerX + 5*scale, y: centerY + 5*scale},
                        {x: centerX, y: centerY + 10*scale},
                        {x: centerX - 5*scale, y: centerY + 5*scale},
                        {x: centerX, y: centerY}
                    ], 10)
                });
                
                // Mouth
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX, y: centerY + 10*scale},
                        {x: centerX, y: centerY + 30*scale},
                        {x: centerX - 10*scale, y: centerY + 40*scale},
                        {x: centerX - 30*scale, y: centerY + 45*scale}
                    ], 15)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX, y: centerY + 30*scale},
                        {x: centerX + 15*scale, y: centerY + 35*scale},
                        {x: centerX + 30*scale, y: centerY + 30*scale}
                    ], 10)
                });
                
                // Whiskers
                for (let i = 0; i < 3; i++) {
                    const offset = i * 5 * scale;
                    paths.push({
                        points: generateSmoothPath([
                            {x: centerX - 10*scale, y: centerY + 5*scale + offset},
                            {x: centerX - 40*scale, y: centerY + offset},
                            {x: centerX - 60*scale, y: centerY - 10*scale + offset}
                        ], 5)
                    });
                    
                    paths.push({
                        points: generateSmoothPath([
                            {x: centerX - 10*scale, y: centerY + 5*scale + offset},
                            {x: centerX - 40*scale, y: centerY + 10*scale + offset},
                            {x: centerX - 60*scale, y: centerY + 20*scale + offset}
                        ], 5)
                    });
                }
                
                // Jerry's facial features
                // Eyes
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 50*scale, y: centerY - 50*scale},
                        {x: centerX + 55*scale, y: centerY - 55*scale},
                        {x: centerX + 60*scale, y: centerY - 50*scale},
                        {x: centerX + 55*scale, y: centerY - 45*scale},
                        {x: centerX + 50*scale, y: centerY - 50*scale}
                    ], 10)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 70*scale, y: centerY - 50*scale},
                        {x: centerX + 75*scale, y: centerY - 55*scale},
                        {x: centerX + 80*scale, y: centerY - 50*scale},
                        {x: centerX + 75*scale, y: centerY - 45*scale},
                        {x: centerX + 70*scale, y: centerY - 50*scale}
                    ], 10)
                });
                
                // Nose
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 60*scale, y: centerY - 40*scale},
                        {x: centerX + 65*scale, y: centerY - 35*scale},
                        {x: centerX + 60*scale, y: centerY - 30*scale}
                    ], 5)
                });
                
                // Mouth
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 60*scale, y: centerY - 30*scale},
                        {x: centerX + 60*scale, y: centerY - 20*scale},
                        {x: centerX + 55*scale, y: centerY - 15*scale}
                    ], 5)
                });
                
                return paths;
            }
            
            // Generate paths for coloring step
            function generateColorPaths() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 1.8;
                
                const paths = [];
                
                // Tom's body (gray)
                paths.push({
                    color: '#a0a0a0',
                    outline: generateSmoothPath([
                        {x: centerX - 50*scale, y: centerY - 20*scale},
                        {x: centerX - 80*scale, y: centerY - 10*scale},
                        {x: centerX - 90*scale, y: centerY + 20*scale},
                        {x: centerX - 80*scale, y: centerY + 50*scale},
                        {x: centerX - 60*scale, y: centerY + 70*scale},
                        {x: centerX - 30*scale, y: centerY + 80*scale},
                        {x: centerX + 10*scale, y: centerY + 70*scale},
                        {x: centerX + 40*scale, y: centerY + 50*scale},
                        {x: centerX + 60*scale, y: centerY + 20*scale},
                        {x: centerX + 60*scale, y: centerY - 20*scale},
                        {x: centerX + 40*scale, y: centerY - 40*scale},
                        {x: centerX + 10*scale, y: centerY - 50*scale},
                        {x: centerX - 30*scale, y: centerY - 40*scale},
                        {x: centerX - 50*scale, y: centerY - 20*scale}
                    ], 30).points,
                    points: generateFillPoints(20)
                });
                
                // Tom's ears (inner pink)
                paths.push({
                    color: '#ffb6c1',
                    outline: generateSmoothPath([
                        {x: centerX - 70*scale, y: centerY - 50*scale},
                        {x: centerX - 80*scale, y: centerY - 40*scale},
                        {x: centerX - 70*scale, y: centerY - 30*scale}
                    ], 10).points,
                    points: generateFillPoints(5)
                });
                
                paths.push({
                    color: '#ffb6c1',
                    outline: generateSmoothPath([
                        {x: centerX - 10*scale, y: centerY - 70*scale},
                        {x: centerX + 10*scale, y: centerY - 80*scale},
                        {x: centerX + 30*scale, y: centerY - 70*scale},
                        {x: centerX + 30*scale, y: centerY - 50*scale}
                    ], 12).points,
                    points: generateFillPoints(5)
                });
                
                // Jerry's body (brown)
                paths.push({
                    color: '#d2b48c',
                    outline: generateSmoothPath([
                        {x: centerX + 20*scale, y: centerY - 80*scale},
                        {x: centerX + 40*scale, y: centerY - 90*scale},
                        {x: centerX + 70*scale, y: centerY - 80*scale},
                        {x: centerX + 90*scale, y: centerY - 60*scale},
                        {x: centerX + 90*scale, y: centerY - 30*scale},
                        {x: centerX + 70*scale, y: centerY - 10*scale},
                        {x: centerX + 40*scale, y: centerY + 10*scale},
                        {x: centerX + 10*scale, y: centerY + 10*scale},
                        {x: centerX - 10*scale, y: centerY + 5*scale},
                        {x: centerX - 20*scale, y: centerY - 10*scale},
                        {x: centerX - 10*scale, y: centerY - 30*scale},
                        {x: centerX + 10*scale, y: centerY - 50*scale},
                        {x: centerX + 20*scale, y: centerY - 80*scale}
                    ], 30).points,
                    points: generateFillPoints(20)
                });
                
                // Jerry's ears (inner pink)
                paths.push({
                    color: '#ffb6c1',
                    outline: generateSmoothPath([
                        {x: centerX + 20*scale, y: centerY - 110*scale},
                        {x: centerX + 40*scale, y: centerY - 120*scale},
                        {x: centerX + 60*scale, y: centerY - 110*scale},
                        {x: centerX + 50*scale, y: centerY - 90*scale}
                    ], 12).points,
                    points: generateFillPoints(5)
                });
                
                paths.push({
                    color: '#ffb6c1',
                    outline: generateSmoothPath([
                        {x: centerX + 80*scale, y: centerY - 110*scale},
                        {x: centerX + 100*scale, y: centerY - 100*scale},
                        {x: centerX + 90*scale, y: centerY - 80*scale}
                    ], 10).points,
                    points: generateFillPoints(5)
                });
                
                // Tom's nose (red)
                paths.push({
                    color: '#ff0000',
                    outline: generateSmoothPath([
                        {x: centerX, y: centerY},
                        {x: centerX + 5*scale, y: centerY + 5*scale},
                        {x: centerX, y: centerY + 10*scale},
                        {x: centerX - 5*scale, y: centerY + 5*scale},
                        {x: centerX, y: centerY}
                    ], 10).points,
                    points: generateFillPoints(3)
                });
                
                // Jerry's nose (black)
                paths.push({
                    color: '#000000',
                    outline: generateSmoothPath([
                        {x: centerX + 60*scale, y: centerY - 40*scale},
                        {x: centerX + 65*scale, y: centerY - 35*scale},
                        {x: centerX + 60*scale, y: centerY - 30*scale}
                    ], 5).points,
                    points: generateFillPoints(2)
                });
                
                return paths;
            }
            
            // Generate paths for shading step
            function generateShadingPaths() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 1.8;
                
                const paths = [];
                
                // Tom's shading
                paths.push({
                    color: '#808080',
                    alpha: 0.3,
                    radius: 8,
                    points: generateRandomPointsInArea([
                        {x: centerX - 70*scale, y: centerY - 20*scale},
                        {x: centerX - 80*scale, y: centerY + 10*scale},
                        {x: centerX - 60*scale, y: centerY + 40*scale},
                        {x: centerX - 30*scale, y: centerY + 50*scale}
                    ], 30)
                });
                
                paths.push({
                    color: '#808080',
                    alpha: 0.2,
                    radius: 6,
                    points: generateRandomPointsInArea([
                        {x: centerX - 40*scale, y: centerY - 30*scale},
                        {x: centerX - 20*scale, y: centerY - 20*scale},
                        {x: centerX - 10*scale, y: centerY + 10*scale},
                        {x: centerX - 30*scale, y: centerY + 30*scale}
                    ], 20)
                });
                
                // Jerry's shading
                paths.push({
                    color: '#a0522d',
                    alpha: 0.3,
                    radius: 6,
                    points: generateRandomPointsInArea([
                        {x: centerX + 60*scale, y: centerY - 70*scale},
                        {x: centerX + 80*scale, y: centerY - 50*scale},
                        {x: centerX + 70*scale, y: centerY - 20*scale},
                        {x: centerX + 50*scale, y: centerY - 40*scale}
                    ], 25)
                });
                
                paths.push({
                    color: '#a0522d',
                    alpha: 0.2,
                    radius: 5,
                    points: generateRandomPointsInArea([
                        {x: centerX + 30*scale, y: centerY - 60*scale},
                        {x: centerX + 50*scale, y: centerY - 50*scale},
                        {x: centerX + 40*scale, y: centerY - 30*scale},
                        {x: centerX + 20*scale, y: centerY - 40*scale}
                    ], 15)
                });
                
                // Highlights
                paths.push({
                    color: '#ffffff',
                    alpha: 0.4,
                    radius: 4,
                    points: [
                        {x: centerX - 60*scale, y: centerY - 30*scale},
                        {x: centerX - 20*scale, y: centerY - 20*scale},
                        {x: centerX + 50*scale, y: centerY - 60*scale},
                        {x: centerX + 70*scale, y: centerY - 60*scale}
                    ]
                });
                
                return paths;
            }
            
            // Generate paths for final step
            function generateFinalPaths() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = 1.8;
                
                const paths = [];
                
                // Final outline touches
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX - 50*scale, y: centerY - 20*scale},
                        {x: centerX - 80*scale, y: centerY - 10*scale},
                        {x: centerX - 90*scale, y: centerY + 20*scale}
                    ], 10)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 60*scale, y: centerY + 20*scale},
                        {x: centerX + 60*scale, y: centerY - 20*scale},
                        {x: centerX + 40*scale, y: centerY - 40*scale}
                    ], 10)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 20*scale, y: centerY - 80*scale},
                        {x: centerX + 40*scale, y: centerY - 90*scale},
                        {x: centerX + 70*scale, y: centerY - 80*scale}
                    ], 10)
                });
                
                paths.push({
                    points: generateSmoothPath([
                        {x: centerX + 90*scale, y: centerY - 30*scale},
                        {x: centerX + 70*scale, y: centerY - 10*scale},
                        {x: centerX + 40*scale, y: centerY + 10*scale}
                    ], 10)
                });
                
                return paths;
            }
            
            // Helper function to generate a smooth path from points
            function generateSmoothPath(points, segments) {
                const result = [];
                
                for (let i = 0; i < points.length; i++) {
                    const p0 = points[(i - 1 + points.length) % points.length];
                    const p1 = points[i];
                    const p2 = points[(i + 1) % points.length];
                    const p3 = points[(i + 2) % points.length];
                    
                    for (let t = 0; t < segments; t++) {
                        const tVal = t / segments;
                        const x = catmullRom(tVal, p0.x, p1.x, p2.x, p3.x);
                        const y = catmullRom(tVal, p0.y, p1.y, p2.y, p3.y);
                        result.push({x, y});
                    }
                }
                
                return { points: result };
            }
            
            // Catmull-Rom spline interpolation
            function catmullRom(t, p0, p1, p2, p3) {
                const v0 = (p2 - p0) * 0.5;
                const v1 = (p3 - p1) * 0.5;
                const t2 = t * t;
                const t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + 
                       (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + 
                       v0 * t + p1;
            }
            
            // Helper function to generate random points within an area
            function generateRandomPointsInArea(area, count) {
                const points = [];
                const minX = Math.min(...area.map(p => p.x));
                const maxX = Math.max(...area.map(p => p.x));
                const minY = Math.min(...area.map(p => p.y));
                const maxY = Math.max(...area.map(p => p.y));
                
                for (let i = 0; i < count; i++) {
                    points.push({
                        x: minX + Math.random() * (maxX - minX),
                        y: minY + Math.random() * (maxY - minY)
                    });
                }
                
                return points;
            }
            
            // Helper function to generate fill points
            function generateFillPoints(count) {
                const points = [];
                for (let i = 0; i < count; i++) {
                    points.push({x: 0, y: 0}); // Actual positions don't matter for fill
                }
                return points;
            }
            
            // Start the animation
            startAnimation();
        });
    </script>
</body>
</html>
